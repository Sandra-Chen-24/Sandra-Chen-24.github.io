<!doctype html><html lang=zh-tw dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='ingress-nginx vs nginx-ingress ingress-nginx (Kubernetes 官方) -> 安裝控制器本身，處理特定業務邏輯的 「Ingress 規則」需要另外建立 kind: Ingress 資源 擴充性極強：內建了許多 Lua 腳本來處理像是 Prometheus 指標、動態平衡（Dynamic Load Balancing）等功能 功能全開：許多進階功能（如 URL 重寫 Rewrite）直接透過 Annotation 就能用 annotation 前綴:nginx.ingress.kubernetes.io/ nginx-ingress (NGINX/F5 官方) 穩定與效能：配置更接近原生 NGINX，邏輯較簡單，執行更穩定 CRDs 管理：他們更傾向使用 VirtualServer 這種自定義資源來管理，而不是寫一堆長長的 Annotation annotation 前綴:nginx.org/ ingress-nginx to gateway 基礎設施定義:ingress-class -> GatewayClass 進入點/IP/TLS:ingress (metadata) -> Gateway 路由規則:ingress (rules) -> HTTPRoute ingress-nginx helm chart 4.7.1 (https://github.com/kubernetes/ingress-nginx/tree/main/charts/ingress-nginx) values.yaml nginx-configuration\nPodDisruptionBudget:.Values.controller.minAvailable # Source: ingress-nginx/templates/controller-poddisruptionbudget.yaml .Values.controller.kind 為 Deployment .Values.controller.autoscaling.enabled 為 true -> .Values.controller.autoscaling.minReplicas > 1 ServiceAccount:{{- if or .Values.serviceAccount.create -}} 沒預設會預設建立 # Source: ingress-nginx/templates/controller-serviceaccount.yaml serviceAccount: create: true name: "" automountServiceAccountToken: true annotations: {} ClusterRole、ClusterRoleBinding、Role、RoleBinding # Source: ingress-nginx/templates/clusterrole.yaml # Source: ingress-nginx/templates/clusterrolebinding.yaml # Source: ingress-nginx/templates/controller-role.yaml # Source: ingress-nginx/templates/controller-rolebinding.yaml ConfigMap:修改這些設定會直接影響整個叢集中所有透過該 Ingress Controller 進出的流量 [在 gateway 中轉換為 GCPBackendPolicy 或 FrontendConfig] # Source: ingress-nginx/templates/controller-configmap.yaml # 安全性與權限 (Security) allow-snippet-annotations:"true"，是否允許在個別的 Ingress 資源中使用 configuration-snippet 等註解來插入自定義 Nginx 設定 http-snippet:是一個非常強大的「後門」設定，直接將原生的 Nginx 配置代碼插入到 nginx.conf 檔案的 http 區塊（block）內 e.g. http-snippet: | server { listen 18080; location /nginx_status { allow all; stub_status on; } location / { return 404; } } -> server: 對應特定的主機名（Host）。（由 server-snippet 設定） -> location: 對應特定的路徑（Path）。（由 location-snippet 或 Ingress Annotation 設定） ssl-dh-param:指定 Diffie-Hellman 演算法的密鑰檔案路徑，用於增強 SSL/TLS 的「完美遠向保密 (Perfect Forward Secrecy)」，防止舊的通訊內容在未來金鑰外洩時被破解 # 真實 IP 與標頭追蹤 (IP & Headers) use-forwarded-headers:"true"，是否信任並傳遞 X-Forwarded-* 標頭 enable-real-ip:"true"，是否啟用 Nginx 的 ngx_http_realip_module 模組，將客戶端的 IP 替換為真實的來源 IP，而不是 Load Balancer 的內部 IP proxy-real-ip-cidr:"0.0.0.0/0"代表完全信任，設定信任的代理伺服器 IP 範圍（CIDR），告訴 Nginx：「來自這些 IP（例如 GCP LB）的流量，請讀取其提供的真實來源 IP」 -> ⚠️ 建議只填入確定的負載平衡器 IP 範圍: GCP HTTP(S) Load Balancer：130.211.0.0/22 和 35.191.0.0/16 Cloudflare：填入 Cloudflare 官方提供的 IP 範圍清單 -> proxy-real-ip-cidr: "130.211.0.0/22,35.191.0.0/16,10.128.0.0/20,203.0.113.5/32" compute-full-forwarded-for:"true"，是否將目前的客戶端 IP 附加到 X-Forwarded-For 清單中，而不是直接覆蓋 add-headers & proxy-set-headers:全域性地在 HTTP 回應（Add）或轉發給後端服務（Set）時加入自定義 Header # 日誌與後端管理 (Logging & Backend) log-format-upstream:自定義發送給後端服務時的日誌格式，通常會加入 $upstream_response_time 等變數，用來監控後端服務的回應速度 e.g. log-format-upstream: &#39;{ "time_iso8601":"$time_iso8601", "http_x_forwarded_for":"$http_x_forwarded_for", "http_host":"$host", "method":"$request_method", "bytes_sent":"$bytes_sent", "pod_name":"$hostname", "path":"$request_uri", "parameters":"$args", "referrer":"$http_referer", "user_agent":"$http_user_agent", "remote_addr":"$remote_addr", "request_time":"$request_time", "request_uri":"$host$request_uri", "request_body":"$request_body", "response_time":"$upstream_response_time", "response_size":"$upstream_response_length", "status_code":"$status", "remote_user":"$remote_user", "time_local":"$time_local", "request":"$request", "body_bytes_sent":"$body_bytes_sent", "request_length":"$request_length", "proxy_upstream_name":"$proxy_upstream_name", "proxy_alternative_upstream_name":"$proxy_alternative_upstream_name", "upstream_addr":"$upstream_addr", "upstream_status":"$upstream_status", "req_id":"$req_id" }&#39; enable-access-log-for-default-backend:"true"，是否記錄「找不到路由 (404)」時導向 Default Backend 的訪問日誌 load-balance:設定負載平衡演算法（預設為 round_robin），可改為 least_conn (最少連接) 或 ewma (指數加權移動平均)，後者在微服務環境中通常能提供更穩定的延遲 Service # controller-service-internal.yaml .Values.controller.service.internal.annotations {{- if and .Values.controller.service.enabled .Values.controller.service.internal.enabled .Values.controller.service.internal.annotations}} -> controller: service: type: LoadBalancer enabled: true externalTrafficPolicy: Local enableHttp: true enableHttps: true ports: http: 80 https: 443 targetPorts: http: http https: https internal: enabled: true loadBalancerSourceRanges: - 10.0.0.0/8 # 預設內網網段全開 loadBalancerIP: "" annotations: external-dns.alpha.kubernetes.io/hostname: template-ingress-internal-lb.out.in.qa.rdapp.vip networking.gke.io/load-balancer-type: Internal # Source: ingress-nginx/templates/controller-service.yaml # Source: ingress-nginx/templates/controller-service-metrics.yaml # Source: ingress-nginx/templates/controller-service-webhook.yaml Deployment # Source: ingress-nginx/templates/controller-deployment.yaml # Source: ingress-nginx/templates/controller-hpa.yaml # Source: ingress-nginx/templates/controller-ingressclass.yaml [IngressClass] # Source: ingress-nginx/templates/controller-prometheusrules.yaml [PrometheusRule] # Source: ingress-nginx/templates/controller-servicemonitor.yaml [ServiceMonitor] # Source: ingress-nginx/templates/admission-webhooks/validating-webhook.yaml [ValidatingWebhookConfiguration] # Source: ingress-nginx/templates/admission-webhooks/cert-manager.yaml [Certificate] # Source: ingress-nginx/templates/admission-webhooks/cert-manager.yaml [Issuer] controller: admissionWebhooks: enabled: true 資源 kind: Ingress ⭐⭐⭐ 全域攔截。當所有其他的 Ingress 規則（Host 或 Path）都匹配失敗時，會轉發到這裡 ✨ 使用 spec.defaultBackend，沒有 rules 區塊，應到 nginx.conf 中的 default_server # Source: php/templates/ingress-default-backend.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: template-default-backend spec: ingressClassName: template-gateway defaultBackend: service: name: template-nginx port: name: http tls: - hosts: - ${host} secretName: wildcard-tls-rdapp-vip ⭐⭐⭐ 精確匹配。只有當請求的 Host 剛好等於 ${host} 且路徑為 / 時才生效 ✨ 使用 spec.rules 區塊，定義明確的路由條件，對應到 nginx.conf 中的特定 server { server_name ${host}; } # Source: php/templates/ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: template annotations: nginx.ingress.kubernetes.io/ssl-redirect: "false" spec: ingressClassName: template-gateway tls: - hosts: - ${host} secretName: wildcard-tls-rdapp-vip rules: - host: ${host} http: paths: - path: / pathType: Prefix backend: service: name: template-nginx port: name: http '><title>ingress-nginx</title><link rel=canonical href=https://sandra-chen-24.github.io/blog/ingress-nginx/ingress-nginx/><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap"><link rel=stylesheet href=/scss/style.min.390cc81d180d80110703ea467e355a4f3a0f44f25d4e957842790824fb5f2ef2.css><meta property='og:title' content="ingress-nginx"><meta property='og:description' content='ingress-nginx vs nginx-ingress ingress-nginx (Kubernetes 官方) -> 安裝控制器本身，處理特定業務邏輯的 「Ingress 規則」需要另外建立 kind: Ingress 資源 擴充性極強：內建了許多 Lua 腳本來處理像是 Prometheus 指標、動態平衡（Dynamic Load Balancing）等功能 功能全開：許多進階功能（如 URL 重寫 Rewrite）直接透過 Annotation 就能用 annotation 前綴:nginx.ingress.kubernetes.io/ nginx-ingress (NGINX/F5 官方) 穩定與效能：配置更接近原生 NGINX，邏輯較簡單，執行更穩定 CRDs 管理：他們更傾向使用 VirtualServer 這種自定義資源來管理，而不是寫一堆長長的 Annotation annotation 前綴:nginx.org/ ingress-nginx to gateway 基礎設施定義:ingress-class -> GatewayClass 進入點/IP/TLS:ingress (metadata) -> Gateway 路由規則:ingress (rules) -> HTTPRoute ingress-nginx helm chart 4.7.1 (https://github.com/kubernetes/ingress-nginx/tree/main/charts/ingress-nginx) values.yaml nginx-configuration\nPodDisruptionBudget:.Values.controller.minAvailable # Source: ingress-nginx/templates/controller-poddisruptionbudget.yaml .Values.controller.kind 為 Deployment .Values.controller.autoscaling.enabled 為 true -> .Values.controller.autoscaling.minReplicas > 1 ServiceAccount:{{- if or .Values.serviceAccount.create -}} 沒預設會預設建立 # Source: ingress-nginx/templates/controller-serviceaccount.yaml serviceAccount: create: true name: "" automountServiceAccountToken: true annotations: {} ClusterRole、ClusterRoleBinding、Role、RoleBinding # Source: ingress-nginx/templates/clusterrole.yaml # Source: ingress-nginx/templates/clusterrolebinding.yaml # Source: ingress-nginx/templates/controller-role.yaml # Source: ingress-nginx/templates/controller-rolebinding.yaml ConfigMap:修改這些設定會直接影響整個叢集中所有透過該 Ingress Controller 進出的流量 [在 gateway 中轉換為 GCPBackendPolicy 或 FrontendConfig] # Source: ingress-nginx/templates/controller-configmap.yaml # 安全性與權限 (Security) allow-snippet-annotations:"true"，是否允許在個別的 Ingress 資源中使用 configuration-snippet 等註解來插入自定義 Nginx 設定 http-snippet:是一個非常強大的「後門」設定，直接將原生的 Nginx 配置代碼插入到 nginx.conf 檔案的 http 區塊（block）內 e.g. http-snippet: | server { listen 18080; location /nginx_status { allow all; stub_status on; } location / { return 404; } } -> server: 對應特定的主機名（Host）。（由 server-snippet 設定） -> location: 對應特定的路徑（Path）。（由 location-snippet 或 Ingress Annotation 設定） ssl-dh-param:指定 Diffie-Hellman 演算法的密鑰檔案路徑，用於增強 SSL/TLS 的「完美遠向保密 (Perfect Forward Secrecy)」，防止舊的通訊內容在未來金鑰外洩時被破解 # 真實 IP 與標頭追蹤 (IP & Headers) use-forwarded-headers:"true"，是否信任並傳遞 X-Forwarded-* 標頭 enable-real-ip:"true"，是否啟用 Nginx 的 ngx_http_realip_module 模組，將客戶端的 IP 替換為真實的來源 IP，而不是 Load Balancer 的內部 IP proxy-real-ip-cidr:"0.0.0.0/0"代表完全信任，設定信任的代理伺服器 IP 範圍（CIDR），告訴 Nginx：「來自這些 IP（例如 GCP LB）的流量，請讀取其提供的真實來源 IP」 -> ⚠️ 建議只填入確定的負載平衡器 IP 範圍: GCP HTTP(S) Load Balancer：130.211.0.0/22 和 35.191.0.0/16 Cloudflare：填入 Cloudflare 官方提供的 IP 範圍清單 -> proxy-real-ip-cidr: "130.211.0.0/22,35.191.0.0/16,10.128.0.0/20,203.0.113.5/32" compute-full-forwarded-for:"true"，是否將目前的客戶端 IP 附加到 X-Forwarded-For 清單中，而不是直接覆蓋 add-headers & proxy-set-headers:全域性地在 HTTP 回應（Add）或轉發給後端服務（Set）時加入自定義 Header # 日誌與後端管理 (Logging & Backend) log-format-upstream:自定義發送給後端服務時的日誌格式，通常會加入 $upstream_response_time 等變數，用來監控後端服務的回應速度 e.g. log-format-upstream: &#39;{ "time_iso8601":"$time_iso8601", "http_x_forwarded_for":"$http_x_forwarded_for", "http_host":"$host", "method":"$request_method", "bytes_sent":"$bytes_sent", "pod_name":"$hostname", "path":"$request_uri", "parameters":"$args", "referrer":"$http_referer", "user_agent":"$http_user_agent", "remote_addr":"$remote_addr", "request_time":"$request_time", "request_uri":"$host$request_uri", "request_body":"$request_body", "response_time":"$upstream_response_time", "response_size":"$upstream_response_length", "status_code":"$status", "remote_user":"$remote_user", "time_local":"$time_local", "request":"$request", "body_bytes_sent":"$body_bytes_sent", "request_length":"$request_length", "proxy_upstream_name":"$proxy_upstream_name", "proxy_alternative_upstream_name":"$proxy_alternative_upstream_name", "upstream_addr":"$upstream_addr", "upstream_status":"$upstream_status", "req_id":"$req_id" }&#39; enable-access-log-for-default-backend:"true"，是否記錄「找不到路由 (404)」時導向 Default Backend 的訪問日誌 load-balance:設定負載平衡演算法（預設為 round_robin），可改為 least_conn (最少連接) 或 ewma (指數加權移動平均)，後者在微服務環境中通常能提供更穩定的延遲 Service # controller-service-internal.yaml .Values.controller.service.internal.annotations {{- if and .Values.controller.service.enabled .Values.controller.service.internal.enabled .Values.controller.service.internal.annotations}} -> controller: service: type: LoadBalancer enabled: true externalTrafficPolicy: Local enableHttp: true enableHttps: true ports: http: 80 https: 443 targetPorts: http: http https: https internal: enabled: true loadBalancerSourceRanges: - 10.0.0.0/8 # 預設內網網段全開 loadBalancerIP: "" annotations: external-dns.alpha.kubernetes.io/hostname: template-ingress-internal-lb.out.in.qa.rdapp.vip networking.gke.io/load-balancer-type: Internal # Source: ingress-nginx/templates/controller-service.yaml # Source: ingress-nginx/templates/controller-service-metrics.yaml # Source: ingress-nginx/templates/controller-service-webhook.yaml Deployment # Source: ingress-nginx/templates/controller-deployment.yaml # Source: ingress-nginx/templates/controller-hpa.yaml # Source: ingress-nginx/templates/controller-ingressclass.yaml [IngressClass] # Source: ingress-nginx/templates/controller-prometheusrules.yaml [PrometheusRule] # Source: ingress-nginx/templates/controller-servicemonitor.yaml [ServiceMonitor] # Source: ingress-nginx/templates/admission-webhooks/validating-webhook.yaml [ValidatingWebhookConfiguration] # Source: ingress-nginx/templates/admission-webhooks/cert-manager.yaml [Certificate] # Source: ingress-nginx/templates/admission-webhooks/cert-manager.yaml [Issuer] controller: admissionWebhooks: enabled: true 資源 kind: Ingress ⭐⭐⭐ 全域攔截。當所有其他的 Ingress 規則（Host 或 Path）都匹配失敗時，會轉發到這裡 ✨ 使用 spec.defaultBackend，沒有 rules 區塊，應到 nginx.conf 中的 default_server # Source: php/templates/ingress-default-backend.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: template-default-backend spec: ingressClassName: template-gateway defaultBackend: service: name: template-nginx port: name: http tls: - hosts: - ${host} secretName: wildcard-tls-rdapp-vip ⭐⭐⭐ 精確匹配。只有當請求的 Host 剛好等於 ${host} 且路徑為 / 時才生效 ✨ 使用 spec.rules 區塊，定義明確的路由條件，對應到 nginx.conf 中的特定 server { server_name ${host}; } # Source: php/templates/ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: template annotations: nginx.ingress.kubernetes.io/ssl-redirect: "false" spec: ingressClassName: template-gateway tls: - hosts: - ${host} secretName: wildcard-tls-rdapp-vip rules: - host: ${host} http: paths: - path: / pathType: Prefix backend: service: name: template-nginx port: name: http '><meta property='og:url' content='https://sandra-chen-24.github.io/blog/ingress-nginx/ingress-nginx/'><meta property='og:site_name' content='Sandra Chen Blog'><meta property='og:type' content='article'><meta property='article:section' content='Blog'><meta property='article:tag' content='ingress-nginx'><meta property='article:published_time' content='2025-12-11T11:30:00+08:00'><meta property='article:modified_time' content='2025-12-11T11:30:00+08:00'><meta name=twitter:title content="ingress-nginx"><meta name=twitter:description content='ingress-nginx vs nginx-ingress ingress-nginx (Kubernetes 官方) -> 安裝控制器本身，處理特定業務邏輯的 「Ingress 規則」需要另外建立 kind: Ingress 資源 擴充性極強：內建了許多 Lua 腳本來處理像是 Prometheus 指標、動態平衡（Dynamic Load Balancing）等功能 功能全開：許多進階功能（如 URL 重寫 Rewrite）直接透過 Annotation 就能用 annotation 前綴:nginx.ingress.kubernetes.io/ nginx-ingress (NGINX/F5 官方) 穩定與效能：配置更接近原生 NGINX，邏輯較簡單，執行更穩定 CRDs 管理：他們更傾向使用 VirtualServer 這種自定義資源來管理，而不是寫一堆長長的 Annotation annotation 前綴:nginx.org/ ingress-nginx to gateway 基礎設施定義:ingress-class -> GatewayClass 進入點/IP/TLS:ingress (metadata) -> Gateway 路由規則:ingress (rules) -> HTTPRoute ingress-nginx helm chart 4.7.1 (https://github.com/kubernetes/ingress-nginx/tree/main/charts/ingress-nginx) values.yaml nginx-configuration\nPodDisruptionBudget:.Values.controller.minAvailable # Source: ingress-nginx/templates/controller-poddisruptionbudget.yaml .Values.controller.kind 為 Deployment .Values.controller.autoscaling.enabled 為 true -> .Values.controller.autoscaling.minReplicas > 1 ServiceAccount:{{- if or .Values.serviceAccount.create -}} 沒預設會預設建立 # Source: ingress-nginx/templates/controller-serviceaccount.yaml serviceAccount: create: true name: "" automountServiceAccountToken: true annotations: {} ClusterRole、ClusterRoleBinding、Role、RoleBinding # Source: ingress-nginx/templates/clusterrole.yaml # Source: ingress-nginx/templates/clusterrolebinding.yaml # Source: ingress-nginx/templates/controller-role.yaml # Source: ingress-nginx/templates/controller-rolebinding.yaml ConfigMap:修改這些設定會直接影響整個叢集中所有透過該 Ingress Controller 進出的流量 [在 gateway 中轉換為 GCPBackendPolicy 或 FrontendConfig] # Source: ingress-nginx/templates/controller-configmap.yaml # 安全性與權限 (Security) allow-snippet-annotations:"true"，是否允許在個別的 Ingress 資源中使用 configuration-snippet 等註解來插入自定義 Nginx 設定 http-snippet:是一個非常強大的「後門」設定，直接將原生的 Nginx 配置代碼插入到 nginx.conf 檔案的 http 區塊（block）內 e.g. http-snippet: | server { listen 18080; location /nginx_status { allow all; stub_status on; } location / { return 404; } } -> server: 對應特定的主機名（Host）。（由 server-snippet 設定） -> location: 對應特定的路徑（Path）。（由 location-snippet 或 Ingress Annotation 設定） ssl-dh-param:指定 Diffie-Hellman 演算法的密鑰檔案路徑，用於增強 SSL/TLS 的「完美遠向保密 (Perfect Forward Secrecy)」，防止舊的通訊內容在未來金鑰外洩時被破解 # 真實 IP 與標頭追蹤 (IP & Headers) use-forwarded-headers:"true"，是否信任並傳遞 X-Forwarded-* 標頭 enable-real-ip:"true"，是否啟用 Nginx 的 ngx_http_realip_module 模組，將客戶端的 IP 替換為真實的來源 IP，而不是 Load Balancer 的內部 IP proxy-real-ip-cidr:"0.0.0.0/0"代表完全信任，設定信任的代理伺服器 IP 範圍（CIDR），告訴 Nginx：「來自這些 IP（例如 GCP LB）的流量，請讀取其提供的真實來源 IP」 -> ⚠️ 建議只填入確定的負載平衡器 IP 範圍: GCP HTTP(S) Load Balancer：130.211.0.0/22 和 35.191.0.0/16 Cloudflare：填入 Cloudflare 官方提供的 IP 範圍清單 -> proxy-real-ip-cidr: "130.211.0.0/22,35.191.0.0/16,10.128.0.0/20,203.0.113.5/32" compute-full-forwarded-for:"true"，是否將目前的客戶端 IP 附加到 X-Forwarded-For 清單中，而不是直接覆蓋 add-headers & proxy-set-headers:全域性地在 HTTP 回應（Add）或轉發給後端服務（Set）時加入自定義 Header # 日誌與後端管理 (Logging & Backend) log-format-upstream:自定義發送給後端服務時的日誌格式，通常會加入 $upstream_response_time 等變數，用來監控後端服務的回應速度 e.g. log-format-upstream: &#39;{ "time_iso8601":"$time_iso8601", "http_x_forwarded_for":"$http_x_forwarded_for", "http_host":"$host", "method":"$request_method", "bytes_sent":"$bytes_sent", "pod_name":"$hostname", "path":"$request_uri", "parameters":"$args", "referrer":"$http_referer", "user_agent":"$http_user_agent", "remote_addr":"$remote_addr", "request_time":"$request_time", "request_uri":"$host$request_uri", "request_body":"$request_body", "response_time":"$upstream_response_time", "response_size":"$upstream_response_length", "status_code":"$status", "remote_user":"$remote_user", "time_local":"$time_local", "request":"$request", "body_bytes_sent":"$body_bytes_sent", "request_length":"$request_length", "proxy_upstream_name":"$proxy_upstream_name", "proxy_alternative_upstream_name":"$proxy_alternative_upstream_name", "upstream_addr":"$upstream_addr", "upstream_status":"$upstream_status", "req_id":"$req_id" }&#39; enable-access-log-for-default-backend:"true"，是否記錄「找不到路由 (404)」時導向 Default Backend 的訪問日誌 load-balance:設定負載平衡演算法（預設為 round_robin），可改為 least_conn (最少連接) 或 ewma (指數加權移動平均)，後者在微服務環境中通常能提供更穩定的延遲 Service # controller-service-internal.yaml .Values.controller.service.internal.annotations {{- if and .Values.controller.service.enabled .Values.controller.service.internal.enabled .Values.controller.service.internal.annotations}} -> controller: service: type: LoadBalancer enabled: true externalTrafficPolicy: Local enableHttp: true enableHttps: true ports: http: 80 https: 443 targetPorts: http: http https: https internal: enabled: true loadBalancerSourceRanges: - 10.0.0.0/8 # 預設內網網段全開 loadBalancerIP: "" annotations: external-dns.alpha.kubernetes.io/hostname: template-ingress-internal-lb.out.in.qa.rdapp.vip networking.gke.io/load-balancer-type: Internal # Source: ingress-nginx/templates/controller-service.yaml # Source: ingress-nginx/templates/controller-service-metrics.yaml # Source: ingress-nginx/templates/controller-service-webhook.yaml Deployment # Source: ingress-nginx/templates/controller-deployment.yaml # Source: ingress-nginx/templates/controller-hpa.yaml # Source: ingress-nginx/templates/controller-ingressclass.yaml [IngressClass] # Source: ingress-nginx/templates/controller-prometheusrules.yaml [PrometheusRule] # Source: ingress-nginx/templates/controller-servicemonitor.yaml [ServiceMonitor] # Source: ingress-nginx/templates/admission-webhooks/validating-webhook.yaml [ValidatingWebhookConfiguration] # Source: ingress-nginx/templates/admission-webhooks/cert-manager.yaml [Certificate] # Source: ingress-nginx/templates/admission-webhooks/cert-manager.yaml [Issuer] controller: admissionWebhooks: enabled: true 資源 kind: Ingress ⭐⭐⭐ 全域攔截。當所有其他的 Ingress 規則（Host 或 Path）都匹配失敗時，會轉發到這裡 ✨ 使用 spec.defaultBackend，沒有 rules 區塊，應到 nginx.conf 中的 default_server # Source: php/templates/ingress-default-backend.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: template-default-backend spec: ingressClassName: template-gateway defaultBackend: service: name: template-nginx port: name: http tls: - hosts: - ${host} secretName: wildcard-tls-rdapp-vip ⭐⭐⭐ 精確匹配。只有當請求的 Host 剛好等於 ${host} 且路徑為 / 時才生效 ✨ 使用 spec.rules 區塊，定義明確的路由條件，對應到 nginx.conf 中的特定 server { server_name ${host}; } # Source: php/templates/ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: template annotations: nginx.ingress.kubernetes.io/ssl-redirect: "false" spec: ingressClassName: template-gateway tls: - hosts: - ${host} secretName: wildcard-tls-rdapp-vip rules: - host: ${host} http: paths: - path: / pathType: Prefix backend: service: name: template-nginx port: name: http '></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><div class=site-meta><h1 class=site-name><a href=/>Sandra Chen Blog</a></h1><h2 class=site-description>Notes & Writings</h2></div></header><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/_index.zh-cn/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/page/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/page/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/page/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/page/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li><a href=/><span>Home</span></a></li><li><a href=/posts/><span>Posts</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/ingress-nginx/ style=background-color:#efbec3;color:#3d0f15>Ingress-Nginx</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/blog/ingress-nginx/ingress-nginx/>ingress-nginx</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2025-12-11T11:30:00+08:00>Thursday, December 11, 2025</time></div></footer></div></header><section class=article-content><h2 id=ingress-nginx-vs-nginx-ingress>ingress-nginx vs nginx-ingress</h2><ul><li>ingress-nginx (Kubernetes 官方) -> 安裝控制器本身，處理特定業務邏輯的 「Ingress 規則」需要另外建立 kind: Ingress 資源<ul><li>擴充性極強：內建了許多 Lua 腳本來處理像是 Prometheus 指標、動態平衡（Dynamic Load Balancing）等功能</li><li>功能全開：許多進階功能（如 URL 重寫 Rewrite）直接透過 Annotation 就能用</li><li>annotation 前綴:nginx.ingress.kubernetes.io/</li></ul></li><li>nginx-ingress (NGINX/F5 官方)<ul><li>穩定與效能：配置更接近原生 NGINX，邏輯較簡單，執行更穩定</li><li>CRDs 管理：他們更傾向使用 VirtualServer 這種自定義資源來管理，而不是寫一堆長長的 Annotation</li><li>annotation 前綴:nginx.org/</li></ul></li></ul><h2 id=ingress-nginx-to-gateway>ingress-nginx to gateway</h2><ul><li>基礎設施定義:ingress-class -> GatewayClass</li><li>進入點/IP/TLS:ingress (metadata) -> Gateway</li><li>路由規則:ingress (rules) -> HTTPRoute</li></ul><h2 id=ingress-nginx-helm-chart-471->ingress-nginx helm chart 4.7.1 (<a class=link href=https://github.com/kubernetes/ingress-nginx/tree/main/charts/ingress-nginx target=_blank rel=noopener>https://github.com/kubernetes/ingress-nginx/tree/main/charts/ingress-nginx</a>)</h2><p><a class=link href=https://github.com/kubernetes/ingress-nginx/blob/helm-chart-4.7.1/charts/ingress-nginx/values.yaml target=_blank rel=noopener>values.yaml</a>
<a class=link href=https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/ target=_blank rel=noopener>nginx-configuration</a></p><ul><li>PodDisruptionBudget:.Values.controller.minAvailable</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># Source: ingress-nginx/templates/controller-poddisruptionbudget.yaml
</span></span><span style=display:flex><span>.Values.controller.kind 為 Deployment
</span></span><span style=display:flex><span>.Values.controller.autoscaling.enabled 為 true -&gt; .Values.controller.autoscaling.minReplicas &gt; 1
</span></span></code></pre></div><ul><li>ServiceAccount:{{- if or .Values.serviceAccount.create -}} 沒預設會預設建立</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># Source: ingress-nginx/templates/controller-serviceaccount.yaml
</span></span><span style=display:flex><span>serviceAccount:
</span></span><span style=display:flex><span>  create: true
</span></span><span style=display:flex><span>  name: &#34;&#34;
</span></span><span style=display:flex><span>  automountServiceAccountToken: true
</span></span><span style=display:flex><span>  annotations: {}
</span></span></code></pre></div><ul><li>ClusterRole、ClusterRoleBinding、Role、RoleBinding</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># Source: ingress-nginx/templates/clusterrole.yaml
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/clusterrolebinding.yaml
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-role.yaml
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-rolebinding.yaml
</span></span></code></pre></div><ul><li>ConfigMap:修改這些設定會直接影響整個叢集中所有透過該 Ingress Controller 進出的流量 [在 gateway 中轉換為 GCPBackendPolicy 或 FrontendConfig]</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># Source: ingress-nginx/templates/controller-configmap.yaml
</span></span><span style=display:flex><span># 安全性與權限 (Security)
</span></span><span style=display:flex><span>allow-snippet-annotations:&#34;true&#34;，是否允許在個別的 Ingress 資源中使用 configuration-snippet 等註解來插入自定義 Nginx 設定
</span></span><span style=display:flex><span>http-snippet:是一個非常強大的「後門」設定，直接將原生的 Nginx 配置代碼插入到 nginx.conf 檔案的 http 區塊（block）內
</span></span><span style=display:flex><span>e.g.
</span></span><span style=display:flex><span>    http-snippet: |
</span></span><span style=display:flex><span>      server {
</span></span><span style=display:flex><span>        listen 18080;
</span></span><span style=display:flex><span>        location /nginx_status {
</span></span><span style=display:flex><span>          allow all;
</span></span><span style=display:flex><span>          stub_status on;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        location / {
</span></span><span style=display:flex><span>          return 404;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>-&gt; server: 對應特定的主機名（Host）。（由 server-snippet 設定）
</span></span><span style=display:flex><span>-&gt; location: 對應特定的路徑（Path）。（由 location-snippet 或 Ingress Annotation 設定）
</span></span><span style=display:flex><span>ssl-dh-param:指定 Diffie-Hellman 演算法的密鑰檔案路徑，用於增強 SSL/TLS 的「完美遠向保密 (Perfect Forward Secrecy)」，防止舊的通訊內容在未來金鑰外洩時被破解
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 真實 IP 與標頭追蹤 (IP &amp; Headers)
</span></span><span style=display:flex><span>use-forwarded-headers:&#34;true&#34;，是否信任並傳遞 X-Forwarded-* 標頭
</span></span><span style=display:flex><span>enable-real-ip:&#34;true&#34;，是否啟用 Nginx 的 ngx_http_realip_module 模組，將客戶端的 IP 替換為真實的來源 IP，而不是 Load Balancer 的內部 IP
</span></span><span style=display:flex><span>proxy-real-ip-cidr:&#34;0.0.0.0/0&#34;代表完全信任，設定信任的代理伺服器 IP 範圍（CIDR），告訴 Nginx：「來自這些 IP（例如 GCP LB）的流量，請讀取其提供的真實來源 IP」
</span></span><span style=display:flex><span>-&gt; ⚠️ 建議只填入確定的負載平衡器 IP 範圍:
</span></span><span style=display:flex><span>  GCP HTTP(S) Load Balancer：130.211.0.0/22 和 35.191.0.0/16
</span></span><span style=display:flex><span>  Cloudflare：填入 Cloudflare 官方提供的 IP 範圍清單
</span></span><span style=display:flex><span>-&gt; proxy-real-ip-cidr: &#34;130.211.0.0/22,35.191.0.0/16,10.128.0.0/20,203.0.113.5/32&#34;
</span></span><span style=display:flex><span>compute-full-forwarded-for:&#34;true&#34;，是否將目前的客戶端 IP 附加到 X-Forwarded-For 清單中，而不是直接覆蓋
</span></span><span style=display:flex><span>add-headers &amp; proxy-set-headers:全域性地在 HTTP 回應（Add）或轉發給後端服務（Set）時加入自定義 Header
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># 日誌與後端管理 (Logging &amp; Backend)
</span></span><span style=display:flex><span>log-format-upstream:自定義發送給後端服務時的日誌格式，通常會加入 $upstream_response_time 等變數，用來監控後端服務的回應速度
</span></span><span style=display:flex><span>e.g.
</span></span><span style=display:flex><span>log-format-upstream: &#39;{ &#34;time_iso8601&#34;:&#34;$time_iso8601&#34;, &#34;http_x_forwarded_for&#34;:&#34;$http_x_forwarded_for&#34;, &#34;http_host&#34;:&#34;$host&#34;, &#34;method&#34;:&#34;$request_method&#34;, &#34;bytes_sent&#34;:&#34;$bytes_sent&#34;, &#34;pod_name&#34;:&#34;$hostname&#34;, &#34;path&#34;:&#34;$request_uri&#34;, &#34;parameters&#34;:&#34;$args&#34;, &#34;referrer&#34;:&#34;$http_referer&#34;, &#34;user_agent&#34;:&#34;$http_user_agent&#34;, &#34;remote_addr&#34;:&#34;$remote_addr&#34;, &#34;request_time&#34;:&#34;$request_time&#34;, &#34;request_uri&#34;:&#34;$host$request_uri&#34;, &#34;request_body&#34;:&#34;$request_body&#34;, &#34;response_time&#34;:&#34;$upstream_response_time&#34;, &#34;response_size&#34;:&#34;$upstream_response_length&#34;, &#34;status_code&#34;:&#34;$status&#34;, &#34;remote_user&#34;:&#34;$remote_user&#34;, &#34;time_local&#34;:&#34;$time_local&#34;, &#34;request&#34;:&#34;$request&#34;, &#34;body_bytes_sent&#34;:&#34;$body_bytes_sent&#34;, &#34;request_length&#34;:&#34;$request_length&#34;, &#34;proxy_upstream_name&#34;:&#34;$proxy_upstream_name&#34;, &#34;proxy_alternative_upstream_name&#34;:&#34;$proxy_alternative_upstream_name&#34;, &#34;upstream_addr&#34;:&#34;$upstream_addr&#34;, &#34;upstream_status&#34;:&#34;$upstream_status&#34;, &#34;req_id&#34;:&#34;$req_id&#34; }&#39;
</span></span><span style=display:flex><span>enable-access-log-for-default-backend:&#34;true&#34;，是否記錄「找不到路由 (404)」時導向 Default Backend 的訪問日誌
</span></span><span style=display:flex><span>load-balance:設定負載平衡演算法（預設為 round_robin），可改為 least_conn (最少連接) 或 ewma (指數加權移動平均)，後者在微服務環境中通常能提供更穩定的延遲
</span></span></code></pre></div><ul><li>Service</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># controller-service-internal.yaml
</span></span><span style=display:flex><span>.Values.controller.service.internal.annotations
</span></span><span style=display:flex><span>{{- if and .Values.controller.service.enabled .Values.controller.service.internal.enabled .Values.controller.service.internal.annotations}}
</span></span><span style=display:flex><span>-&gt;
</span></span><span style=display:flex><span>controller:
</span></span><span style=display:flex><span>    service:
</span></span><span style=display:flex><span>        type: LoadBalancer
</span></span><span style=display:flex><span>        enabled: true
</span></span><span style=display:flex><span>        externalTrafficPolicy: Local
</span></span><span style=display:flex><span>        enableHttp: true
</span></span><span style=display:flex><span>        enableHttps: true
</span></span><span style=display:flex><span>        ports:
</span></span><span style=display:flex><span>          http: 80
</span></span><span style=display:flex><span>          https: 443
</span></span><span style=display:flex><span>        targetPorts:
</span></span><span style=display:flex><span>          http: http
</span></span><span style=display:flex><span>          https: https
</span></span><span style=display:flex><span>        internal:
</span></span><span style=display:flex><span>            enabled: true
</span></span><span style=display:flex><span>            loadBalancerSourceRanges:
</span></span><span style=display:flex><span>                - 10.0.0.0/8 # 預設內網網段全開
</span></span><span style=display:flex><span>            loadBalancerIP: &#34;&#34;
</span></span><span style=display:flex><span>            annotations:
</span></span><span style=display:flex><span>                external-dns.alpha.kubernetes.io/hostname: template-ingress-internal-lb.out.in.qa.rdapp.vip
</span></span><span style=display:flex><span>                networking.gke.io/load-balancer-type: Internal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-service.yaml
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-service-metrics.yaml
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-service-webhook.yaml
</span></span></code></pre></div><ul><li>Deployment</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span># Source: ingress-nginx/templates/controller-deployment.yaml
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-hpa.yaml
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-ingressclass.yaml [IngressClass]
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-prometheusrules.yaml [PrometheusRule]
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/controller-servicemonitor.yaml [ServiceMonitor]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/admission-webhooks/validating-webhook.yaml [ValidatingWebhookConfiguration]
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/admission-webhooks/cert-manager.yaml [Certificate]
</span></span><span style=display:flex><span># Source: ingress-nginx/templates/admission-webhooks/cert-manager.yaml [Issuer]
</span></span><span style=display:flex><span>controller:
</span></span><span style=display:flex><span>  admissionWebhooks:
</span></span><span style=display:flex><span>    enabled: true
</span></span></code></pre></div><h2 id=資源-kind-ingress>資源 kind: Ingress</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-text data-lang=text><span style=display:flex><span>⭐⭐⭐ 全域攔截。當所有其他的 Ingress 規則（Host 或 Path）都匹配失敗時，會轉發到這裡
</span></span><span style=display:flex><span>✨ 使用 spec.defaultBackend，沒有 rules 區塊，應到 nginx.conf 中的 default_server
</span></span><span style=display:flex><span># Source: php/templates/ingress-default-backend.yaml
</span></span><span style=display:flex><span>apiVersion: networking.k8s.io/v1
</span></span><span style=display:flex><span>kind: Ingress
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name:  template-default-backend
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ingressClassName: template-gateway
</span></span><span style=display:flex><span>  defaultBackend:
</span></span><span style=display:flex><span>    service:
</span></span><span style=display:flex><span>      name: template-nginx
</span></span><span style=display:flex><span>      port:
</span></span><span style=display:flex><span>        name: http
</span></span><span style=display:flex><span>  tls:
</span></span><span style=display:flex><span>    - hosts:
</span></span><span style=display:flex><span>        - ${host}
</span></span><span style=display:flex><span>      secretName: wildcard-tls-rdapp-vip
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>⭐⭐⭐ 精確匹配。只有當請求的 Host 剛好等於 ${host} 且路徑為 / 時才生效
</span></span><span style=display:flex><span>✨ 使用 spec.rules 區塊，定義明確的路由條件，對應到 nginx.conf 中的特定 server { server_name ${host}; }
</span></span><span style=display:flex><span># Source: php/templates/ingress.yaml
</span></span><span style=display:flex><span>apiVersion: networking.k8s.io/v1
</span></span><span style=display:flex><span>kind: Ingress
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  name: template
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    nginx.ingress.kubernetes.io/ssl-redirect: &#34;false&#34;
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  ingressClassName: template-gateway
</span></span><span style=display:flex><span>  tls:
</span></span><span style=display:flex><span>    - hosts:
</span></span><span style=display:flex><span>        - ${host}
</span></span><span style=display:flex><span>      secretName: wildcard-tls-rdapp-vip
</span></span><span style=display:flex><span>  rules:
</span></span><span style=display:flex><span>    - host: ${host}
</span></span><span style=display:flex><span>      http:
</span></span><span style=display:flex><span>        paths:
</span></span><span style=display:flex><span>          - path: /
</span></span><span style=display:flex><span>            pathType: Prefix
</span></span><span style=display:flex><span>            backend:
</span></span><span style=display:flex><span>              service:
</span></span><span style=display:flex><span>                name: template-nginx
</span></span><span style=display:flex><span>                port:
</span></span><span style=display:flex><span>                  name: http
</span></span></code></pre></div></section><footer class=article-footer><section class=article-tags><a href=/tags/ingress-nginx/>Ingress-Nginx</a></section></footer></article><div class=disqus-container></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2025 -
2026 Sandra Chen Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=4.0.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><script type=module>
    import gallery from '\/ts\/gallery.js';

    const articleContent = document.querySelector('.article-content');
    const shouldLoad = articleContent && (articleContent.querySelectorAll('figure').length > 0 || articleContent.querySelectorAll('img.gallery-image').length > 0);
    
    if (shouldLoad) {
        gallery(articleContent);

        const PhotoSwipeLightbox = (await import("https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js")).default;
        const styleHref = "https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe.css";

        const styleTag = document.createElement('link');
        styleTag.rel = 'stylesheet';
        styleTag.href = styleHref;
        document.head.appendChild(styleTag);

        const lightbox = new PhotoSwipeLightbox({
            gallerySelector: '.article-content',
            childSelector: 'figure a.image-link',
            pswpModule: () => import("https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js")
        });
        lightbox.init();
    }
</script></main></div><script type=text/javascript src=/ts/main.acaf849f2b273f6a8368a58b001f336738d0c948d92e79b116467d0c7515f932.js defer></script></body></html>